#include <iostream>
#include <stack>

using namespace std;

int main()
{
    int n, dest[1050];
    stack<int> stk;
	cin >> n;
	for(int i=1; i<=n; i++) {
		cin >> dest[i];
    }
    // 遍历dest[1~n]，遍历需要出栈的列车编号，每次出栈一次。思路就是**模拟栈**，不是出栈的值就入栈，是就出栈。

    // 别人模拟栈的思路(这种模拟的思路很好！！！)：BCA，车站c相当于一个栈.我们用模拟法来做，假设我们已经处理了前i-1节从B方向驶出的车厢.我们现在要让ai驶岀. 
        // 若ai不在车站C中，就让若干车厢从A方向驶入车站C,直到ai驶入.再将它从B方向装出，
        // ai在车站C中，如果它是车站C中停在最前面的，则将它从B方向駛出.否则原问题无解.
            // 如样例中.出桟序列是3 5 4 2 1 .模拟过程如下，
            // ①  一开始栈为空，
            // ②  由于3不在栈中，就需要把1,2.3依次进栈.再出栈，这样符合出栈序列第一个数为3,当前栈为｛1，2}
            // ③  第2个出枚的是5,5不在栈中，就要把4.5压栈，再出栈就可以得到5,此时検为｛1,2，4｝
            // ④  第3个出校的是4,正好是栈顶元素，直接出栈，栈变为{1，2}
            // ⑤  第4个出栈的是2,正好是栈顶元素，直接出栈，栈变为（2}
            // ⑥  第5个出校的是1,正好是栈頂元素，直接出栈，栈变为｛｝.
            // 在模拟过程中没有碰到要出栈的数在栈中但不是栈頂元素的情况，所以该方案可行

    // 如果从遍历入栈的列车编号的思路出发，不好解。（这种思路就是一步步模拟）因为遍历出栈循序，若出栈失败则返回false，而遍历入栈顺序的出栈不好控制(出栈后要while出栈，要需要出while的出口)。
    for(int i = 1, cur = 1; i <= n; i++) {   // cur为当前从A方向驶入的列车编号 
		while(cur <= dest[i]) {
			stk.push(cur++);  // 若cur比需要出栈数字dest[i]小，则要先将cur压栈 
        }
		if(stk.top() == dest[i]) {    //出栈 
			stk.pop();
        } else {
            cout<<"NO"<<endl;
            return 0;
        }
	}
    cout<<"YES"<<endl;
	return 0;
 }
